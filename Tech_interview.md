# Tech Interview

[TOC]

# OS

1. Process와 Thread의 차이

   Process : 실행 중인 프로그램

   Thread : 프로세스 안에서 실행되는 흐름의 단위

   프로세스는 메모리에서 자신만의 고유 공간과 자원을 할당받아 사용하지만, 스레드는 프로세스 내에서 다른 스레드와 code, data를 공유하고 독자적인 stack+program counter만 사용함.



2. Context Switching

   CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정

   PCB(Process Control Block)에 프로세스의 상태를 저장하고, 읽어옴.



3. PCB?

   운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보.

   (1) OS가 관리상 사용하는 정보

   (2) CPU 수행 관련 하드웨어 값(program counter, registers)

   (3) code, data, stack의 위치 정보

   (4) 파일 관련 정보(open file descriptors)



4. 멀티프로세스 vs 멀티스레드

   멀티프로세스는 안정적이지만, context switching으로 인한 오버헤드가 크다.

   멀티스레드를 사용하면 자원을 효율적으로 사용할 수 있지만 동기화 문제(다른 스레드의 자원에 접근하므로), 하나의 스레드에 오류가 발생하면 모든 스레드가 작동 불가해지는 문제가 생길 수 있다.



5. 동기와 비동기의 차이

   동기식 : 한 함수가 끝나기를 기다리고 다른 함수를 실행

   비동기식 : 한 함수가 끝나기를 기다리지 않고 다음 함수를 실행

   1) 동기식 입출력과 비동기식 입출력?

      동기식 입출력 : 입출력 작업이 완료된 후에 제어가 사용자 프로그램에 넘어감(기다릴수도, 다른 프로그램을 실행할수도 있음)

      비동기식 입출력 : 입출력 작업이 완료되기를 기다리지 않고 제어를 즉시 사용자 프로그램으로 넘김

   2. 웹에서 동기식 비동기식

      이벤트 루프 : 콜 스택, web api, 태스크 큐

      비동기 함수를 호출->web api에 보내서 처리->처리가 완료되면 태스크 큐로 보냄->콜 스택으로 콜백함수를 보내고 실행



6. Blocking/Non blocking

   blocking : system call이 끝날 때 까지 프로그램이 대기해야함

   non blocking : system call이 완료되지 않아도 대기하지 않고 return

   동기 논블로킹 : polling 문제



7. 가상 메모리

   프로세스 전체가 메모리에 올라오지 않더라도 실행이 가능. 실제 메모리의 크기와 상관 없이 메모리를 이용할 수 있도록 함.

   실제 메모리와 보조 기억장치의 swap area로 구성됨.



8. 세마포어와 뮤텍스

   뮤텍스 : 공유 자원을 사용하기 전에 설정하고 사용한 후에 해제하는 잠금

   공유 자원에 한 번에 한개의 프로세스만 접근 가능하도록 관리하는 방식

   세마포어 : 일반화된 뮤텍스. 공유 자원에 세마포어 변수만큼의 프로세스가 접근할 수 있음.

   현재 수행중이 아닌 다른 프로세스가 세마포어를 해제할 수 있음

   뮤텍스는 락을 획득한 프로세스가 반드시 그 락을 해제해야 함.



9. 데드락

   두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태

   무한히 다음 자원을 기다리게 되는 상태를 말한다.

   시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.

   

   발생조건 : 상호배제 : 자원을 한번에 한 프로세스만 사용할 수 있음, 점유대기 : 하나의 자원을 점유하며 다른 자원을 위해 대기하는 프로세스 존재, 비선점 : 다른 프로세스가 점유한 자원은 사용이 끝날 때 까지 강제로 빼앗을 수 없음, 순환대기 : 순환 형태로 대기해야 함

   

   처리 방법 : 예방 or 회피

   예방은 발생조건 넷 중 하나를 제거하면서 해결한다. 자원 낭비가 엄청 심하다.

   회피는 은행원 알고리즘을 사용. 자원을 할당한 후에도 안정 상태인지 검사하여, 그렇다면 자원을 할당.

   



# Database

1. 인덱스

   검색성능을 향상시키기 위해 사용

   따로 테이블을 만들어야 하므로 자원 소모, 이진트리를 사용하기 때문에 기본적으로 정렬되어 있는데 잦은 데이터에 변경이 있다면 인덱스 테이블을 변경해야 하므로 성능 저하 발생

   데이터의 중복이 높은 컬럼(=카디널리티 낮은 컬럼)은 인덱스로 만들어도 별로 의미가 없다


   INSERT : 정렬하여 저장해야 하므로 비효율

   DELETE : 테이블에서만 삭제되고 인덱스 테이블에는 남아있어 쿼리 수행속도 저하

   UPDATE : 인덱스 테이블에서 DELETE, INSERT 모두 해야함


   다중 컬럼 인덱싱 할 때 카디널리티가 높은 컬럼->낮은 컬럼 순으로 해야 효율적



2. B+ 트리와 B- 트리

   B- 트리 : k진 트리 인가봄

   B+ 트리 : 리프 노드에만 포인터를 저장, 무조건 리프 노드까지 내려가야 하지만 리프 노드는 연결리스트로 탐색이 가능



3. 정규화

   목적 : 중복 방지, 무결성

   제1정규화 : 테이블 컬럼이 원자값을 갖도록 레코드를 분리

   제2정규화 : 모든 컬럼이 키에 대해 종속성이 없도록 테이블을 분리

   제3정규화 : 모든 컬럼이 다른 속성에 의한 종속성이 없도록 테이블을 분리

   정규화를 하면 한 테이블의 크기가 작아지고 입력 수정 삭제가 빨라지지만, 릴레이션이 분해되어 조인이 많아지므로 조회 성능이 저하되기도 한다. 이럴 때 반정규화를 고려할 수 있다.



4. 트랜잭션

   하나의 그룹으로 처리되어야 하는 명령문들. 모두 정상적으로 처리되어야 db에 반영하고, 그렇지 않으면 전체 취소한다.



5. UNION/UNION ALL 차이

   UNION ALL은 두 테이블 모조리 붙임, UNION은 중복된 원소 제거하고 붙임

# Network

1. 브라우저에서 주소창에 url 입력시 어떤일이 일어나는가

   브라우저의 주소창에 url 입력

   브라우저 캐시에서 DNS 레코드를 확인하여 IP주소를 찾음 (없다면 DNS resolver를 통해 IP주소를 알아냄)

   브라우저가 서버와 TCP 연결을 시작함

   브라우저가 웹 서버에 HTTP 요청을 보냄

   서버가 요청을 처리하고 응답을 되돌려보냄

   브라우저는 서버가 보낸 HTML 내용을 표시



# Language

1. GIL이란

   파이썬에서 한 쓰레드만 object에 접근할 수 있도록 하는 것.

   그래서 웬만하면 CPython의 멀티쓰레드는 느리다. 예외적으로 입출력이 많거나 한 경우에는 괜찮다.

   멀티쓰레드 하고싶으면 PyPy 등으로 짜는게 좋다.



2. Garbage Collection

   파이썬에서는 Reference Counting 기법으로 수행됨.



제너레이터, 이터레이터, 코루틴, 함수형 프로그래밍





# OOP, 디자인 패턴

1. SOLID

   Single Responsibility Principle : 하나의 클래스는 하나의 역할만 해야 함

   Open - Close Principle : 확장(상속)에는 열려있고, 수정에는 닫혀 있어야 함

   Liskov Substitution Principle : 자식이 부모의 자리에 항상 교체될 수 있어야 함

   Interface Segregation Principle : 인터페이스가 잘 분리되어서, 클래스가 꼭 필요한 인터페이스만 구현하도록 해야함

   Dependency Inversion Property : 상위 모듈이 하위 모듈에 의존하면 안됨.

   

2. 싱글톤 패턴

   하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴

   데이터베이스 연결 모듈에 쓰임. 메모리 낭비를 방지할 수 있다. TDD를 할 때 불편하다.



3. 팩토리 메소드 패턴

   생성하는 객체를 별도로 둔다.

   그 객체에 넘어오는 값에 따라서 다른 객체를 만든다.



# Miscellaneous

1. Hadoop

   분산저장(HDFS), 분산처리(MapReduce)

2. Hive

   데이터 웨어하우스, 데이터 요약 질의 및 분석 기능을 제공함

3. Spark

   분산 인메모리 프로세싱 엔진. 하둡을 지원함

4. Docker

   CI/CD : VCS에 push가 되면 테스트와 빌드가 수행되어 안정적인 배포파일을 만드는 것을 CI(Continuous Integration), 이 빌드 결과를 자동으로 서버에 배포하는 것을 CD(Continuons Deployment) 라고 합니다.

   CI/CD를 사용하는 목적은 테스트 자동화와 개발에만 신경쓸 수 있다는 점에 있음

5. 암호화

   크게 양방향과 단방향으로 나눔.

   양방향은 다시 대칭키와 비대칭키로 나눔.

   비대칭키의 예시 RSA 암호화 : 송신자가 공개키로 암호화하면 수신자가 비밀키로 복호화.

   단방향 암호화의 예시 : HASH, 데이터베이스에 비밀번호나 토큰 같은거 넣을때
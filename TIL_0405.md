# TIL_0405



# 최소신장트리



# 1. 크루스칼 알고리즘

1. 간선을 크기가 작은 순으로 정렬함
2. 정렬된 간선을 하나씩 선택
3. 간선을 이루는 두 노드의 부모가 같다면 사이클이 형성되는 것이므로 버림
4. 부모가 같지 않다면 유니온 해주고, 전체 비용에 추가

```python
def union(x,y):
    a=find(x)
    b=find(y)

    parent[max(a,b)]=min(a,b)

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])

    return parent[x]

V,E=map(int,input().split())
parent=[i for i in range(V+1)]

graph=[]

for _ in range(E):
    u,v,w=map(int,input().split())
    graph.append([u,v,w])

graph.sort(key=lambda x:x[2]) # O(ElogE)

ans=0
for start,end,cost in graph: # E번 반복
    if find(start)!=find(end): # find함수, union함수 모두 평균 시간복잡도 O(logV)
        union(start,end)
        ans+=cost

print(ans)
```

정렬의 시간복잡도 ElogE, E번 반복하며 find함수를 최대 3회 호출하는 부분 3*ElogV 이므로 크루스칼 알고리즘의 시간복잡도 O(ElogE)=O(ElogV) (V-1<=E<V^2) 



# 2. 프림 알고리즘

1. 그래프에서 하나의 꼭짓점을 선택하여 시작
2. 트리와 연결된 변 가운데 사이클을 만들지 않는 가장 가중치가 작은 변을 트리에 추가한다.
3. 연결된 변의 갯수가 V-1이 될때까지 반복

```python
import heapq
V,E=map(int,input().split())
graph=[[] for _ in range(V+1)]

for _ in range(E):
    u,v,w=map(int,input().split())

    graph[u].append([w,v])
    graph[v].append([w,u])

def prim(start):
    visited=[0]*(V+1)
    q=[[0,start]]
    ans=0
    cnt=0

    while cnt<V:
        cost,node=heapq.heappop(q) # heappop 시간복잡도 O(logV), V번 실행됨

        if visited[node]:
            continue

        visited[node]=1
        ans+=cost
        cnt+=1

        for w,v in graph[node]:
            heapq.heappush(q,[w,v]) # heappush 시간복잡도 O(logV), E번 실행됨

    return ans

print(prim(1))
```



시간복잡도 다익스트라와 같음

1. 인접행렬+탐색을 사용한 경우(수업시간에한코드) O(V^2)
2. **이진힙과 인접리스트를 사용한 경우 O((V+E)logV)=O(ElogV)**

3. 피보나치 힙을 사용한 경우 O(E+VlogV)



# 3. 비교

별 차이 없다

간선이 많은 경우는 프림이 좀 더 유리하고, 간선이 성긴 경우에는 크루스칼이 좀 더 유리하다